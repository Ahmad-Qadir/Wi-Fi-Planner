<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wi-Fi LinkPlanner — Floor Grid Simulation</title>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">

<style>
  body { padding: 1.5rem; background:#f8f9fa; }
  .controls { background: white; padding: 1rem; border-radius: .5rem; box-shadow: 0 0 10px rgba(0,0,0,0.04); }
  .grid-wrap { overflow:auto; background: white; padding: 1rem; border-radius: .5rem; box-shadow: 0 0 10px rgba(0,0,0,0.04); }
  .grid { display: inline-block; border: 1px solid #ddd; }
  .cell { width: 28px; height: 28px; display:inline-flex; justify-content:center; align-items:center; margin:1px; font-size:10px; color:#fff; border-radius:4px; cursor: pointer; user-select:none; }
  .cell.wall { background:#6c757d; color:white; font-weight:600; }
  .cell.ap { outline: 2px solid #000; background: #e0f7fa; color: #000; font-weight:700; }
  .rssi-tooltip { font-size:11px; }
  .legend-dot { display:inline-block; width:14px; height:14px; vertical-align:middle; margin-right:6px; border-radius:3px; }
  .summary { margin-top:.5rem; }
  /* colors for RSSI */
  .strong { background: #28a745; }
  .medium { background: #ffc107; color:#000; }
  .weak { background: #dc3545; }
  .no-signal { background: #6c757d; }
  .controls .small { font-size:.85rem; color:#6c757d; }
</style>
</head>
<body>
<div class="container">
  <div class="row g-3">
    <div class="col-lg-4">
      <div class="controls">
        <h4>Wi-Fi LinkPlanner</h4>
        <p class="small">Draw room size, place AP (click a cell), place walls (click cell to toggle), and inspect RSSI per cell.</p>

        <div class="mb-2">
          <label class="form-label">Room width (m)</label>
          <input id="roomWidth" type="number" class="form-control" value="10" min="3" step="1">
        </div>

        <div class="mb-2">
          <label class="form-label">Room height (m)</label>
          <input id="roomHeight" type="number" class="form-control" value="8" min="3" step="1">
        </div>

        <div class="mb-2">
          <label class="form-label">Cell size (m) — cell represents 1 cell² meters</label>
          <select id="cellSize" class="form-select">
            <option value="1" selected>1 m</option>
            <option value="0.5">0.5 m</option>
            <option value="0.25">0.25 m</option>
          </select>
        </div>

        <hr>

        <div class="mb-2">
          <label class="form-label">AP Transmit Power (dBm)</label>
          <input id="Ptx" type="range" min="5" max="30" value="20" class="form-range">
          <div class="d-flex justify-content-between">
            <small id="PtxVal">20 dBm</small>
            <small class="small">Change to see realtime update</small>
          </div>
        </div>

        <div class="mb-2">
          <label class="form-label">Frequency</label>
          <select id="freq" class="form-select">
            <option value="2400" selected>2.4 GHz</option>
            <option value="5000">5 GHz</option>
          </select>
        </div>

        <hr>

        <div class="mb-2">
          <label class="form-label">Wall type to place</label>
          <select id="wallType" class="form-select">
            <option value="15" selected>Concrete — 15 dB</option>
            <option value="7">Glass — 7 dB</option>
            <option value="5">Plastic — 5 dB</option>
          </select>
        </div>

        <div class="d-grid gap-2">
          <button id="generateBtn" class="btn btn-primary">Generate Grid</button>
          <button id="clearWallsBtn" class="btn btn-outline-secondary">Clear Walls</button>
          <button id="resetBtn" class="btn btn-outline-danger">Reset AP & Walls</button>
        </div>

        <hr>

        <div class="summary">
          <div><strong>Mode:</strong> <span id="modeLabel">Place AP / Toggle wall</span></div>
          <div class="mt-2"><strong>Summary</strong></div>
          <div class="mt-1">
            <span class="legend-dot strong"></span> <small>Strong (&gt; -65 dBm)</small><br>
            <span class="legend-dot medium" style="background:#ffc107"></span> <small>Medium (-75 to -65 dBm)</small><br>
            <span class="legend-dot weak"></span> <small>Weak (&le; -75 dBm)</small><br>
            <span class="legend-dot no-signal" style="background:#6c757d"></span> <small>Wall cell / No signal</small>
          </div>

          <div class="mt-3">
            <p class="mb-1 small">Total cells: <span id="totalCells">0</span></p>
            <p class="mb-1 small">Strong cells: <span id="countStrong">0</span></p>
            <p class="mb-1 small">Medium cells: <span id="countMedium">0</span></p>
            <p class="mb-1 small">Weak cells: <span id="countWeak">0</span></p>
            <p class="mb-1 small">Walls placed: <span id="wallCount">0</span></p>
          </div>
        </div>

        <hr>
        <div class="small text-muted">Instructions: Click "Generate Grid", click any cell to place the AP (only one AP allowed). Click other cells to toggle walls. AP cell cannot be wall. Change sliders / settings to update RSSI in real time.</div>
      </div>
    </div>

    <div class="col-lg-8">
      <div class="grid-wrap">
        <div id="gridContainer" class="d-flex justify-content-center align-items-center" style="min-height: 400px;">
          <!-- grid generated here -->
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Client-side simulation script
  - grid is width x height measured in meters, cellSize meters per cell (square)
  - cells are arranged with (cols = Math.ceil(width / cellSize), rows = Math.ceil(height / cellSize))
  - place AP by clicking a cell (single AP)
  - toggle walls by clicking non-AP cells
  - walls are stored as per-cell wallLoss (0=oent)
  - when computing RSSI for a target cell, we step along the line from AP cell to target cell and sum wall losses of any crossed cells (Bresenham-like)
  - FSPL uses distance (meters -> km) and frequency (MHz)
*/

const generateBtn = document.getElementById('generateBtn');
const clearWallsBtn = document.getElementById('clearWallsBtn');
const resetBtn = document.getElementById('resetBtn');
const PtxInput = document.getElementById('Ptx');
const PtxVal = document.getElementById('PtxVal');
const freqSelect = document.getElementById('freq');
const wallTypeSelect = document.getElementById('wallType');
const gridContainer = document.getElementById('gridContainer');
const roomWidthInput = document.getElementById('roomWidth');
const roomHeightInput = document.getElementById('roomHeight');
const cellSizeSelect = document.getElementById('cellSize');

const totalCellsEl = document.getElementById('totalCells');
const countStrongEl = document.getElementById('countStrong');
const countMediumEl = document.getElementById('countMedium');
const countWeakEl = document.getElementById('countWeak');
const wallCountEl = document.getElementById('wallCount');

let grid = []; // 2D array of cell objects
let cols = 0, rows = 0;
let ap = null; // {x, y}
let cellSize = parseFloat(cellSizeSelect.value);

PtxVal.textContent = PtxInput.value + ' dBm';

PtxInput.addEventListener('input', () => {
  PtxVal.textContent = PtxInput.value + ' dBm';
  renderGrid(); // realtime update
});
freqSelect.addEventListener('change', renderGrid);
wallTypeSelect.addEventListener('change', () => {});
roomWidthInput.addEventListener('change', ()=>{});
roomHeightInput.addEventListener('change', ()=>{});
cellSizeSelect.addEventListener('change', ()=>{
  cellSize = parseFloat(cellSizeSelect.value);
});

generateBtn.addEventListener('click', () => {
  createGrid();
  renderGrid();
});

clearWallsBtn.addEventListener('click', () => {
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      grid[r][c].wallLoss = 0;
    }
  }
  ap = null;
  updateSummary();
  renderGrid();
});

resetBtn.addEventListener('click', () => {
  ap = null;
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      grid[r][c].wallLoss = 0;
    }
  }
  renderGrid();
});

function createGrid(){
  const width = Math.max(1, parseFloat(roomWidthInput.value));
  const height = Math.max(1, parseFloat(roomHeightInput.value));
  cellSize = parseFloat(cellSizeSelect.value);

  cols = Math.max(3, Math.ceil(width / cellSize));
  rows = Math.max(3, Math.ceil(height / cellSize));

  grid = [];
  for (let r=0;r<rows;r++){
    const row = [];
    for (let c=0;c<cols;c++){
      row.push({
        x: c,
        y: r,
        wallLoss: 0,   // 0 if no wall, otherwise dB
        el: null       // DOM element
      });
    }
    grid.push(row);
  }

  // reset AP
  ap = null;

  // build DOM
  buildGridDOM();
  updateSummary();
}

function buildGridDOM(){
  gridContainer.innerHTML = '';
  const gridEl = document.createElement('div');
  gridEl.className = 'grid';
  gridEl.style.padding = '8px';
  gridEl.style.background = '#fff';
  gridEl.style.display = 'inline-block';

  for (let r=0;r<rows;r++){
    const rowWrap = document.createElement('div');
    for (let c=0;c<cols;c++){
      const cell = document.createElement('div');
      cell.className = 'cell noselect';
      cell.style.width = (28) + 'px';
      cell.style.height = (28) + 'px';
      cell.dataset.x = c;
      cell.dataset.y = r;
      cell.title = `Cell ${c},${r}`;

      // click handler: if AP not set, set AP; else toggle wall (unless clicking AP)
      cell.addEventListener('click', (ev)=>{
        const cx = parseInt(cell.dataset.x);
        const cy = parseInt(cell.dataset.y);
        const clicked = grid[cy][cx];

        if (!ap){
          // set AP
          ap = { x: cx, y: cy };
          cell.classList.add('ap');
          cell.textContent = 'AP';
        } else {
          // if clicking AP again -> remove AP
          if (ap.x === cx && ap.y === cy) {
            ap = null;
          } else {
            // toggle wall at clicked cell (AP cell cannot be wall)
            if (!(ap.x === cx && ap.y === cy)){
              const loss = parseFloat(wallTypeSelect.value);
              if (clicked.wallLoss === 0){
                clicked.wallLoss = loss;
                cell.classList.add('wall');
                cell.textContent = 'W';
              } else {
                clicked.wallLoss = 0;
                cell.classList.remove('wall');
                cell.textContent = '';
              }
            }
          }
        }
        renderGrid();
      });

      rowWrap.appendChild(cell);
      grid[r][c].el = cell;
    }
    gridEl.appendChild(rowWrap);
  }
  gridContainer.appendChild(gridEl);
}

// Bresenham line algorithm to step through cells between two points
function bresenham(x0, y0, x1, y1){
  const points = [];
  let dx = Math.abs(x1 - x0);
  let dy = Math.abs(y1 - y0);
  let sx = (x0 < x1) ? 1 : -1;
  let sy = (y0 < y1) ? 1 : -1;
  let err = dx - dy;

  while(true){
    points.push({x: x0, y: y0});
    if (x0 === x1 && y0 === y1) break;
    let e2 = err * 2;
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx)  { err += dx; y0 += sy; }
  }
  return points;
}

function calculateCellRSSI(cellX, cellY){
  if (!ap) return null;

  // distance in meters between centers
  const dx = (cellX - ap.x) * cellSize;
  const dy = (cellY - ap.y) * cellSize;
  let distance = Math.sqrt(dx*dx + dy*dy);

  // if same cell, use a minimum distance to avoid infinite FSPL
  if (distance < 0.5) distance = 0.5;

  // count walls crossed along path
  const path = bresenham(ap.x, ap.y, cellX, cellY);

  // exclude ap cell (path[0]) and target cell? include walls encountered excluding AP cell
  let totalWallLoss = 0;
  for (let p of path){
    // skip the AP cell itself
    if (p.x === ap.x && p.y === ap.y) continue;
    // if we reach target cell, include its wallLoss (so a wall on the target cell blocks)
    if (grid[p.y] && grid[p.y][p.x]){
      totalWallLoss += grid[p.y][p.x].wallLoss;
    }
  }

  // FSPL
  const Ptx = parseFloat(PtxInput.value);
  const freq = parseFloat(freqSelect.value); // MHz
  const d_km = distance / 1000;
  const fspl = 20 * Math.log10(d_km) + 20 * Math.log10(freq) + 32.44;

  const rssi = Ptx - fspl - totalWallLoss;
  return { rssi, distance, totalWallLoss, fspl };
}

function renderGrid(){
  if (!grid || grid.length === 0) return;

  let strong=0, medium=0, weak=0, walls=0;
  for (let r=0;r<rows;r++){
    for (let c=0;c<cols;c++){
      const cellObj = grid[r][c];
      const el = cellObj.el;
      el.classList.remove('strong','medium','weak','no-signal','ap','wall');
      el.textContent = '';

      if (ap && ap.x === c && ap.y === r) {
        el.classList.add('ap');
        el.textContent = 'AP';
        continue;
      }

      if (cellObj.wallLoss && cellObj.wallLoss > 0){
        el.classList.add('wall');
        el.textContent = 'W';
        walls++;
        // treat wall cell as no-signal visually, but still include in counts? We show as no-signal
        el.classList.add('no-signal');
        el.title = `Wall: ${cellObj.wallLoss} dB`;
        continue;
      }

      const data = calculateCellRSSI(c, r);
      if (!data){
        el.classList.add('no-signal');
        el.title = `No AP placed`;
        continue;
      }

      const rssi = data.rssi;
      const tooltip = `RSSI: ${rssi.toFixed(2)} dBm\nDist: ${data.distance.toFixed(2)} m\nWallLoss: ${data.totalWallLoss} dB\nFSPL: ${data.fspl.toFixed(2)} dB`;
      el.title = tooltip;

      if (rssi > -65){
        el.classList.add('strong');
        strong++;
      } else if (rssi > -75){
        el.classList.add('medium');
        medium++;
      } else {
        el.classList.add('weak');
        weak++;
      }

      // show small value inside cell (rounded)
      el.textContent = Math.round(rssi);
    }
  }

  totalCellsEl.textContent = (rows*cols);
  countStrongEl.textContent = strong;
  countMediumEl.textContent = medium;
  countWeakEl.textContent = weak;
  wallCountEl.textContent = walls;
}

// initial grid generation
createGrid();
renderGrid();

</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
