<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wi-Fi LinkPlanner</title>
<link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/93/93158.png">

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
  :root {
    --bg-0: #0c111b;
    --bg-1: #121826;
    --glass: rgba(255, 255, 255, 0.08);
    --glass-strong: rgba(255, 255, 255, 0.12);
    --stroke: rgba(255, 255, 255, 0.18);
    --ink: #eef3fb;
    --muted: rgba(238, 243, 251, 0.68);
    --accent: #5de0e6;
    --accent-2: #b58fff;
    --success: #70f1a8;
    --warning: #ffd68a;
  }

  body {
    padding: 18px;
    min-height: 100vh;
    font-family: "Sora", system-ui, -apple-system, "Segoe UI", sans-serif;
    color: var(--ink);
    background:
      radial-gradient(1000px 700px at 10% 10%, rgba(93, 224, 230, 0.12), transparent 60%),
      radial-gradient(900px 700px at 90% 0%, rgba(181, 143, 255, 0.14), transparent 55%),
      linear-gradient(160deg, var(--bg-0), var(--bg-1));
    overflow-x: hidden;
  }

  .bg-orb {
    position: fixed;
    inset: auto;
    width: 340px;
    height: 340px;
    border-radius: 999px;
    filter: blur(18px);
    opacity: 0.6;
    z-index: 0;
    pointer-events: none;
  }
  .orb-1 { background: radial-gradient(circle, rgba(93, 224, 230, 0.45), transparent 65%); top: -120px; left: -80px; }
  .orb-2 { background: radial-gradient(circle, rgba(181, 143, 255, 0.45), transparent 65%); top: 40px; right: -140px; }
  .orb-3 { background: radial-gradient(circle, rgba(112, 241, 168, 0.4), transparent 65%); bottom: -140px; left: 20%; }

  .app-shell { position: relative; z-index: 1; }

  .app-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 18px;
    padding: 18px 22px;
    margin-bottom: 18px;
  }
  .header-text h1 { font-size: 1.6rem; margin: 4px 0 6px; }
  .header-text .eyebrow { text-transform: uppercase; letter-spacing: 0.2em; font-size: 0.65rem; color: var(--muted); }
  .header-actions { display: flex; gap: 10px; flex-wrap: wrap; }

  .layout-grid {
    display: grid;
    grid-template-columns: 340px minmax(0, 1fr);
    gap: 18px;
  }
  .sidebar, .main { display: flex; flex-direction: column; gap: 16px; }

  .panel {
    padding: 16px;
  }
  .panel-title {
    font-weight: 600;
    letter-spacing: 0.02em;
    margin-bottom: 10px;
  }
  .panel-sub { color: var(--muted); font-size: 0.82rem; margin-top: 6px; }

  .canvas-card { padding: 16px; position: relative; }
  .canvas-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
  .canvas-meta { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
  .chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.08);
    color: var(--muted);
    font-size: 0.75rem;
    position: relative;
    overflow: hidden;
  }
  .chip-soft { background: rgba(10, 16, 28, 0.55); color: var(--ink); }
  .canvas-wrap { overflow: auto; border-radius: 12px; }

  .canvas-card::before {
    content: "";
    position: absolute;
    inset: 10px 10px auto 10px;
    height: 56px;
    border-radius: 16px;
    background: linear-gradient(120deg, rgba(93, 224, 230, 0.18), rgba(181, 143, 255, 0.18), rgba(112, 241, 168, 0.18));
    filter: blur(20px);
    opacity: 0.7;
    animation: headerGlow 9s ease-in-out infinite;
    pointer-events: none;
  }

  .canvas-wrap::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 12px;
    background: linear-gradient(120deg, rgba(255, 255, 255, 0.08), transparent 40%, rgba(93, 224, 230, 0.08), transparent 70%);
    animation: shimmer 6s ease-in-out infinite;
    pointer-events: none;
    mix-blend-mode: screen;
  }

  .canvas-wrap {
    position: relative;
    overflow: hidden;
    border-radius: 12px;
  }

  .chip::after {
    content: "";
    position: absolute;
    right: 8px;
    top: 50%;
    width: 6px;
    height: 6px;
    border-radius: 999px;
    background: rgba(112, 241, 168, 0.9);
    transform: translateY(-50%);
    box-shadow: 0 0 0 0 rgba(112, 241, 168, 0.6);
    animation: pulseDot 2.6s ease-in-out infinite;
  }
  .chip-soft::after { display: none; }

  @keyframes shimmer {
    0% { transform: translateX(-20%); opacity: 0.2; }
    50% { transform: translateX(10%); opacity: 0.45; }
    100% { transform: translateX(40%); opacity: 0.2; }
  }
  @keyframes headerGlow {
    0% { opacity: 0.5; transform: translateY(0); }
    50% { opacity: 0.8; transform: translateY(6px); }
    100% { opacity: 0.5; transform: translateY(0); }
  }
  @keyframes pulseDot {
    0% { box-shadow: 0 0 0 0 rgba(112, 241, 168, 0.5); opacity: 0.8; }
    70% { box-shadow: 0 0 0 10px rgba(112, 241, 168, 0); opacity: 1; }
    100% { box-shadow: 0 0 0 0 rgba(112, 241, 168, 0); opacity: 0.8; }
  }

  .canvas-hud {
    position: absolute;
    right: 22px;
    top: 62px;
    display: grid;
    gap: 8px;
    z-index: 2;
  }
  .hud-group {
    display: grid;
    gap: 6px;
    padding: 8px;
    border-radius: 14px;
    background: rgba(10, 16, 28, 0.65);
    border: 1px solid rgba(255, 255, 255, 0.18);
    backdrop-filter: blur(10px);
  }
  .hud-btn {
    width: 36px;
    height: 36px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.18);
    background: rgba(255, 255, 255, 0.08);
    color: var(--ink);
  }
  .hud-btn.active { box-shadow: 0 0 0 0.2rem rgba(93,224,230,0.25); }

  .insights-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 16px;
  }
  .stat-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 8px 14px;
    font-size: 0.88rem;
  }
  .stat-grid span { color: var(--ink); font-weight: 600; }

  .inspector-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 10px 14px;
  }
  .inspector-item {
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(10, 16, 28, 0.5);
  }
  .inspector-item span { display: block; color: var(--muted); font-size: 0.72rem; letter-spacing: 0.08em; text-transform: uppercase; }
  .inspector-item strong { font-weight: 600; font-size: 0.95rem; }
  .sparkline {
    width: 100%;
    height: 56px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(10, 16, 28, 0.45);
  }

  .glass-card {
    background: linear-gradient(140deg, var(--glass), rgba(255, 255, 255, 0.02));
    border: 1px solid var(--stroke);
    border-radius: 18px;
    box-shadow:
      0 18px 40px rgba(0, 0, 0, 0.28),
      inset 0 1px 0 rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(16px);
  }

  .controls { padding: 18px; }
  .grid-wrap { padding: 14px; min-height: 560px; }

  #simCanvas {
    background: rgba(5, 8, 16, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 14px;
    display: block;
    cursor: crosshair;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
  }

  .form-control,
  .form-select,
  .input-group-text {
    background: rgba(10, 16, 28, 0.55);
    border: 1px solid rgba(255, 255, 255, 0.18);
    color: var(--ink);
  }

  .form-control:focus,
  .form-select:focus {
    border-color: rgba(93, 224, 230, 0.7);
    box-shadow: 0 0 0 0.2rem rgba(93, 224, 230, 0.2);
  }

  .btn {
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.18);
    backdrop-filter: blur(10px);
  }
  .btn-primary {
    background: linear-gradient(120deg, #44c7d9, #7a6df0);
    border-color: rgba(255, 255, 255, 0.2);
  }
  .btn-outline-primary,
  .btn-outline-secondary,
  .btn-outline-danger,
  .btn-outline-success,
  .btn-outline-dark {
    color: var(--ink);
    border-color: rgba(255, 255, 255, 0.2);
  }

  .mode-btn{ margin-right:6px; margin-bottom:6px; }
  .btn-mode-active{ box-shadow:0 0 0 0.24rem rgba(93,224,230,0.25); }

  .legend-bar{
    width:200px; height:14px; border-radius:999px;
    background:linear-gradient(90deg,#ff6b6b,#ffd166,#7cf7a1);
    border:1px solid rgba(255,255,255,0.35);
  }

  .small-muted{ font-size:.86rem; color: var(--muted); }
  .footer-note{ font-size:.83rem; color: var(--muted); margin-top:8px; }

  .results { color: var(--muted); }
  .form-label { color: var(--muted); font-weight: 500; letter-spacing: 0.02em; }
  h5 { font-weight: 600; letter-spacing: 0.01em; }

  @media (max-width: 992px) {
    body { padding: 12px; }
    .grid-wrap { min-height: 420px; }
    .layout-grid { grid-template-columns: 1fr; }
    .insights-grid { grid-template-columns: 1fr; }
    .app-header { flex-direction: column; align-items: flex-start; }
    .inspector-grid { grid-template-columns: 1fr 1fr; }
    .canvas-hud { position: static; flex-direction: row; display: flex; flex-wrap: wrap; }
  }
</style>
</head>
<body>
<div class="bg-orb orb-1"></div>
<div class="bg-orb orb-2"></div>
<div class="bg-orb orb-3"></div>
<div class="container-fluid app-shell">
  <div class="app-header glass-card">
    <div class="header-text">
      <div class="eyebrow">Wi-Fi LinkPlanner</div>
      <h1>Coverage Studio</h1>
      <p class="small-muted">Freehand walls, per-cell RSSI, and smart auto-placement to visualize coverage in seconds.</p>
    </div>
    <div class="header-actions">
      <button id="exportBtn" class="btn btn-outline-primary btn-sm">Export Heatmap PNG</button>
      <button id="fitBtn" class="btn btn-outline-secondary btn-sm">Fit to View</button>
    </div>
  </div>

  <div class="layout-grid">
    <aside class="sidebar">
      <div class="panel glass-card">
        <div class="panel-title">Room Setup</div>
        <div class="mb-2">
          <label class="form-label">Room Width (m)</label>
          <input id="roomW" class="form-control" type="number" value="10" min="2" step="0.5">
        </div>
        <div class="mb-2">
          <label class="form-label">Room Height (m)</label>
          <input id="roomH" class="form-control" type="number" value="8" min="2" step="0.5">
        </div>
        <div class="mb-2">
          <label class="form-label">Cell Size (m)</label>
          <select id="cellSize" class="form-select">
            <option value="1">1 m</option>
            <option value="0.5">0.5 m</option>
            <option value="0.25">0.25 m</option>
          </select>
        </div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Floorplan Image</div>
        <div class="mb-2">
          <label class="form-label">Upload Image</label>
          <input id="bgUpload" class="form-control" type="file" accept="image/*">
        </div>
        <div class="d-grid">
          <button id="bgClear" class="btn btn-outline-secondary btn-sm">Remove Image</button>
        </div>
        <div class="panel-sub">Images are scaled to fit the grid area.</div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Signal</div>
        <div class="mb-2">
          <label class="form-label">AP Transmit Power (dBm)</label>
          <input id="Ptx" type="range" class="form-range" min="5" max="30" value="20">
          <div class="d-flex justify-content-between">
            <small id="PtxVal">20 dBm</small><small class="small-muted">Realtime update</small>
          </div>
        </div>

        <div class="mb-2">
          <label for="numUsers" class="form-label">Expected Number of Users:</label>
          <input type="number" id="numUsers" class="form-control" min="1" value="20">
        </div>

        <div class="mb-2">
          <label class="form-label">Frequency</label>
          <select id="freq" class="form-select">
            <option value="2400">2.4 GHz</option>
            <option value="5000">5 GHz</option>
          </select>
        </div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Walls</div>
        <div class="mb-2">
          <label class="form-label">Wall Type (loss dB)</label>
          <select id="wallType" class="form-select">
            <option value="15">Concrete — 15 dB</option>
            <option value="20">Reinforced Concrete — 20 dB</option>
            <option value="12">Brick — 12 dB</option>
            <option value="9">Drywall — 9 dB</option>
            <option value="7">Glass — 7 dB</option>
            <option value="10">Metal Stud — 10 dB</option>
            <option value="18">Metal Door — 18 dB</option>
            <option value="5">Plastic — 5 dB</option>
            <option value="3">Wood — 3 dB</option>
            <option value="1">Curtain — 1 dB</option>
          </select>
        </div>
        <div class="form-check form-switch mt-2">
          <input class="form-check-input" type="checkbox" id="snapWalls" checked>
          <label class="form-check-label small-muted" for="snapWalls">Snap walls to grid edges</label>
        </div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Actions</div>
        <div class="mb-2 d-grid gap-2">
          <button id="generateBtn" class="btn btn-primary">Generate Grid</button>
          <button id="clearWallsBtn" class="btn btn-outline-secondary">Clear Walls</button>
          <button id="clearAllBtn" class="btn btn-outline-danger">Reset APs & Walls</button>
        </div>

        <div class="mb-2">
          <div class="input-group input-group-sm">
            <span class="input-group-text">Auto-place APs</span>
            <input id="autoCount" type="number" class="form-control" value="2" min="1" max="10">
            <button id="autoPlaceBtn" class="btn btn-outline-success">Run</button>
          </div>
          <div class="panel-sub">Greedy + local refinement optimizer.</div>
        </div>
        <div class="footer-note">Tip: Use Draw Wall to drag continuous walls. Auto-place proposes optimized AP positions.</div>
      </div>
    </aside>

    <main class="main">
      <div class="canvas-card glass-card">
        <div class="canvas-header">
          <div class="chip"><i class="bi bi-radar"></i> Live Canvas</div>
          <div class="canvas-meta">
            <div class="chip chip-soft">Mode: <span id="liveMode">Add AP</span></div>
            <div class="chip chip-soft">Grid: <span id="liveGrid">0 x 0</span></div>
            <div class="chip chip-soft">Room: <span id="liveRoom">0 x 0 m</span></div>
          </div>
        </div>
        <div class="canvas-hud">
          <div class="hud-group">
            <button class="hud-btn" id="hudAdd" title="Add AP"><i class="bi bi-router"></i></button>
            <button class="hud-btn" id="hudMove" title="Move AP"><i class="bi bi-arrows-move"></i></button>
            <button class="hud-btn" id="hudErase" title="Erase AP"><i class="bi bi-x-circle"></i></button>
            <button class="hud-btn" id="hudDraw" title="Draw Wall"><i class="bi bi-pencil"></i></button>
            <button class="hud-btn" id="hudEraseWall" title="Erase Wall"><i class="bi bi-eraser"></i></button>
          </div>
          <div class="hud-group">
            <button class="hud-btn" id="hudZoomIn" title="Zoom In"><i class="bi bi-zoom-in"></i></button>
            <button class="hud-btn" id="hudZoomOut" title="Zoom Out"><i class="bi bi-zoom-out"></i></button>
            <button class="hud-btn" id="hudFit" title="Fit to View"><i class="bi bi-aspect-ratio"></i></button>
            <button class="hud-btn" id="hudGrid" title="Toggle Grid"><i class="bi bi-grid"></i></button>
          </div>
        </div>
        <div class="canvas-wrap">
          <canvas id="simCanvas"></canvas>
        </div>
      </div>

      <div class="insights-grid">
        <div class="panel glass-card">
          <div class="panel-title">Signal Legend</div>
          <div class="d-flex align-items-center gap-2">
            <div class="legend-bar" id="legendBar"></div>
            <div>
              <div class="small-muted">-95 dBm</div>
              <div class="small-muted">-65 dBm</div>
              <div class="small-muted">-35 dBm</div>
            </div>
          </div>
        </div>
        <div class="panel glass-card">
          <div class="panel-title">Coverage Stats</div>
          <div class="stat-grid">
            <div>Cells: <span id="statTotal">0</span></div>
            <div>Walls: <span id="statWalls">0</span></div>
            <div>Strong (> -65 dBm): <span id="statStrong">0</span></div>
            <div>Medium (-75 to -65): <span id="statMedium">0</span></div>
            <div>Weak (≤ -75): <span id="statWeak">0</span></div>
            <div>APs: <span id="statAps">0</span></div>
          </div>
        </div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Inspector</div>
        <div class="inspector-grid">
          <div class="inspector-item"><span>Mode</span><strong id="insMode">Add AP</strong></div>
          <div class="inspector-item"><span>Hover Cell</span><strong id="insCell">—</strong></div>
          <div class="inspector-item"><span>RSSI</span><strong id="insRSSI">—</strong></div>
          <div class="inspector-item"><span>Best AP</span><strong id="insBestAp">—</strong></div>
          <div class="inspector-item"><span>Distance</span><strong id="insDist">—</strong></div>
          <div class="inspector-item"><span>Wall Loss</span><strong id="insLoss">—</strong></div>
        </div>
        <div class="panel-title mt-3">Selected AP</div>
        <div class="inspector-grid">
          <div class="inspector-item"><span>AP</span><strong id="insSelAp">—</strong></div>
          <div class="inspector-item"><span>Position</span><strong id="insSelPos">—</strong></div>
          <div class="inspector-item"><span>TX Power</span><strong id="insSelTx">—</strong></div>
          <div class="inspector-item"><span>Strong Cells</span><strong id="insSelScore">—</strong></div>
          <div class="inspector-item"><span>Covered Cells</span><strong id="insSelCovered">—</strong></div>
          <div class="inspector-item"><span>Avg RSSI</span><strong id="insSelAvg">—</strong></div>
        </div>
        <div class="mt-3">
          <div class="small-muted">Coverage sparkline</div>
          <canvas id="insSpark" class="sparkline" width="460" height="56"></canvas>
        </div>
        <div class="panel-sub">Hover the canvas to inspect cells. Click an AP to inspect details.</div>
      </div>

      <div class="panel glass-card">
        <div class="panel-title">Results</div>
        <div class="results mt-2"></div>
      </div>
    </main>
  </div>
</div>

<script>
/* Full client-side advanced simulator with freehand walls, RSSI numbers, and optimized auto-placement.
   - Multi APs: array aps {xIndex,yIndex,ptx}
   - Walls: array polylines; each polyline = array of points in grid-index space + loss
   - Freehand drawing records mousemove points and stores as segments
   - For intersection: check segment intersections with wall segments (all polyline segments)
   - Auto placement: greedy then local refinement (hill-climb on AP positions)
*/

// ----- DOM refs -----
const simCanvas = document.getElementById('simCanvas');
const ctx = simCanvas.getContext('2d');

const roomW = document.getElementById('roomW');
const roomH = document.getElementById('roomH');
const cellSizeSel = document.getElementById('cellSize');
const PtxInput = document.getElementById('Ptx');
const PtxVal = document.getElementById('PtxVal');
const freqSel = document.getElementById('freq');
const wallTypeSel = document.getElementById('wallType');
const snapWalls = document.getElementById('snapWalls');

const modeAddAP = document.getElementById('modeAddAP');
const modeMoveAP = document.getElementById('modeMoveAP');
const modeEraseAP = document.getElementById('modeEraseAP');
const modeDrawWall = document.getElementById('modeDrawWall');
const modeEraseWall = document.getElementById('modeEraseWall');

const generateBtn = document.getElementById('generateBtn');
const clearWallsBtn = document.getElementById('clearWallsBtn');
const clearAllBtn = document.getElementById('clearAllBtn');
const autoPlaceBtn = document.getElementById('autoPlaceBtn');
const autoCount = document.getElementById('autoCount');
const exportBtn = document.getElementById('exportBtn');
const fitBtn = document.getElementById('fitBtn');
const bgUpload = document.getElementById('bgUpload');
const bgClear = document.getElementById('bgClear');

const hudAdd = document.getElementById('hudAdd');
const hudMove = document.getElementById('hudMove');
const hudErase = document.getElementById('hudErase');
const hudDraw = document.getElementById('hudDraw');
const hudEraseWall = document.getElementById('hudEraseWall');
const hudZoomIn = document.getElementById('hudZoomIn');
const hudZoomOut = document.getElementById('hudZoomOut');
const hudFit = document.getElementById('hudFit');
const hudGrid = document.getElementById('hudGrid');

const liveMode = document.getElementById('liveMode');
const liveGrid = document.getElementById('liveGrid');
const liveRoom = document.getElementById('liveRoom');

const insMode = document.getElementById('insMode');
const insCell = document.getElementById('insCell');
const insRSSI = document.getElementById('insRSSI');
const insBestAp = document.getElementById('insBestAp');
const insDist = document.getElementById('insDist');
const insLoss = document.getElementById('insLoss');
const insSelAp = document.getElementById('insSelAp');
const insSelPos = document.getElementById('insSelPos');
const insSelTx = document.getElementById('insSelTx');
const insSelScore = document.getElementById('insSelScore');
const insSelCovered = document.getElementById('insSelCovered');
const insSelAvg = document.getElementById('insSelAvg');
const insSpark = document.getElementById('insSpark');

const statTotal = document.getElementById('statTotal');
const statStrong = document.getElementById('statStrong');
const statMedium = document.getElementById('statMedium');
const statWeak = document.getElementById('statWeak');
const statWalls = document.getElementById('statWalls');
const statAps = document.getElementById('statAps');

const legendBar = document.getElementById('legendBar');

let W = 10, H = 8, cellSize = 1;
let cols = 0, rows = 0;
let cells = []; // {xIndex,yIndex,cx,cy,rssi,bestAPIndex}
let aps = [];   // {xIndex,yIndex,ptx}
let walls = []; // {points:[{x,y},...], loss} store in grid-index coordinates
let selectedAPIndex = null;
let bgImage = null;
let bgImageUrl = null;

// canvas & drawing params
let pad = 20;
let scale = 40;
let manualScale = null;
let RSSI_MIN = -95, RSSI_MAX = -35;
let showGrid = true;

let mode = 'addAP';
function setMode(m){
  mode = m;
  [modeAddAP,modeMoveAP,modeEraseAP,modeDrawWall,modeEraseWall].forEach(b=>b && b.classList.remove('btn-mode-active'));
  if (m==='addAP' && modeAddAP) modeAddAP.classList.add('btn-mode-active');
  if (m==='moveAP' && modeMoveAP) modeMoveAP.classList.add('btn-mode-active');
  if (m==='eraseAP' && modeEraseAP) modeEraseAP.classList.add('btn-mode-active');
  if (m==='drawWall' && modeDrawWall) modeDrawWall.classList.add('btn-mode-active');
  if (m==='eraseWall' && modeEraseWall) modeEraseWall.classList.add('btn-mode-active');
  [hudAdd, hudMove, hudErase, hudDraw, hudEraseWall].forEach(b=>b && b.classList.remove('active'));
  if (m==='addAP' && hudAdd) hudAdd.classList.add('active');
  if (m==='moveAP' && hudMove) hudMove.classList.add('active');
  if (m==='eraseAP' && hudErase) hudErase.classList.add('active');
  if (m==='drawWall' && hudDraw) hudDraw.classList.add('active');
  if (m==='eraseWall' && hudEraseWall) hudEraseWall.classList.add('active');
  updateLiveMeta();
}
if (modeAddAP) modeAddAP.addEventListener('click', ()=> setMode('addAP'));
if (modeMoveAP) modeMoveAP.addEventListener('click', ()=> setMode('moveAP'));
if (modeEraseAP) modeEraseAP.addEventListener('click', ()=> setMode('eraseAP'));
if (modeDrawWall) modeDrawWall.addEventListener('click', ()=> setMode('drawWall'));
if (modeEraseWall) modeEraseWall.addEventListener('click', ()=> setMode('eraseWall'));
setMode('addAP');

if (hudAdd) hudAdd.addEventListener('click', ()=> setMode('addAP'));
if (hudMove) hudMove.addEventListener('click', ()=> setMode('moveAP'));
if (hudErase) hudErase.addEventListener('click', ()=> setMode('eraseAP'));
if (hudDraw) hudDraw.addEventListener('click', ()=> setMode('drawWall'));
if (hudEraseWall) hudEraseWall.addEventListener('click', ()=> setMode('eraseWall'));
if (hudZoomIn) hudZoomIn.addEventListener('click', ()=> zoomCanvas(4));
if (hudZoomOut) hudZoomOut.addEventListener('click', ()=> zoomCanvas(-4));
if (hudFit) hudFit.addEventListener('click', ()=> fitToView());
if (hudGrid) hudGrid.addEventListener('click', ()=>{
  showGrid = !showGrid;
  hudGrid.classList.toggle('active', showGrid);
  draw();
});

function modeLabel(m){
  if (m === 'addAP') return 'Add AP';
  if (m === 'moveAP') return 'Move AP';
  if (m === 'eraseAP') return 'Erase AP';
  if (m === 'drawWall') return 'Draw Wall';
  if (m === 'eraseWall') return 'Erase Wall';
  return 'Idle';
}

function updateLiveMeta(){
  const label = modeLabel(mode);
  if (liveMode) liveMode.textContent = label;
  if (insMode) insMode.textContent = label;
  if (liveGrid) liveGrid.textContent = `${cols} x ${rows}`;
  if (liveRoom) liveRoom.textContent = `${W} x ${H} m`;
}

// mouse state
let isMouseDown = false;
let currentPoly = null;
let moveAPIndex = null;

// helpers
function fitCanvas(){
  const maxWidth = Math.max(600, window.innerWidth - 460);
  const maxHeight = Math.max(400, window.innerHeight - 160);
  if (manualScale === null){
    scale = Math.floor(Math.min((maxWidth - 2*pad) / cols, (maxHeight - 2*pad) / rows));
    scale = Math.max(10, Math.min(60, scale));
  } else {
    scale = Math.max(10, Math.min(60, manualScale));
  }
  applyScale();
}

function drawBackgroundImage(ctx2, areaX, areaY, areaW, areaH){
  if (!bgImage) return;
  const imgW = bgImage.naturalWidth || bgImage.width;
  const imgH = bgImage.naturalHeight || bgImage.height;
  if (!imgW || !imgH) return;
  const scale = Math.min(areaW / imgW, areaH / imgH);
  const drawW = imgW * scale;
  const drawH = imgH * scale;
  const dx = areaX + (areaW - drawW) / 2;
  const dy = areaY + (areaH - drawH) / 2;
  ctx2.drawImage(bgImage, dx, dy, drawW, drawH);
}

if (bgUpload){
  bgUpload.addEventListener('change', (e)=>{
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    if (bgImageUrl) URL.revokeObjectURL(bgImageUrl);
    bgImageUrl = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ bgImage = img; draw(); };
    img.src = bgImageUrl;
  });
}

if (bgClear){
  bgClear.addEventListener('click', ()=>{
    if (bgImageUrl) URL.revokeObjectURL(bgImageUrl);
    bgImageUrl = null;
    bgImage = null;
    if (bgUpload) bgUpload.value = '';
    draw();
  });
}

function applyScale(){
  if (cols === 0 || rows === 0) return;
  simCanvas.width = pad*2 + cols*scale;
  simCanvas.height = pad*2 + rows*scale;
  draw();
}

function fitToView(){
  manualScale = null;
  fitCanvas();
}

function zoomCanvas(delta){
  manualScale = Math.max(10, Math.min(60, (manualScale ?? scale) + delta));
  applyScale();
}

function toPixelX(ix){ return pad + ix*scale + scale/2; }
function toPixelY(iy){ return pad + iy*scale + scale/2; }
function pixelToIndex(px, py){
  const ix = Math.floor((px - pad) / scale);
  const iy = Math.floor((py - pad) / scale);
  if (ix < 0 || iy < 0 || ix >= cols || iy >= rows) return null;
  return {ix, iy};
}

function generateGrid(){
  W = Math.max(1, parseFloat(roomW.value) || 10);
  H = Math.max(1, parseFloat(roomH.value) || 8);
  cellSize = parseFloat(cellSizeSel.value) || 1;
  cols = Math.max(3, Math.ceil(W / cellSize));
  rows = Math.max(3, Math.ceil(H / cellSize));
  cells = [];
  for (let y=0;y<rows;y++){
    for (let x=0;x<cols;x++){
      const cx = (x + 0.5) * cellSize;
      const cy = (y + 0.5) * cellSize;
      cells.push({xIndex:x,yIndex:y,cx,cy,rssi:null,bestAP:null});
    }
  }
  fitCanvas();
  draw();
  updateLiveMeta();
}

function roundedRectPath(ctx2, x, y, w, h, r){
  const radius = Math.min(r, w / 2, h / 2);
  ctx2.beginPath();
  ctx2.moveTo(x + radius, y);
  ctx2.lineTo(x + w - radius, y);
  ctx2.quadraticCurveTo(x + w, y, x + w, y + radius);
  ctx2.lineTo(x + w, y + h - radius);
  ctx2.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
  ctx2.lineTo(x + radius, y + h);
  ctx2.quadraticCurveTo(x, y + h, x, y + h - radius);
  ctx2.lineTo(x, y + radius);
  ctx2.quadraticCurveTo(x, y, x + radius, y);
  ctx2.closePath();
}

function gridStepForScale(px){
  if (px >= 46) return 1;
  if (px >= 32) return 2;
  if (px >= 22) return 4;
  return 8;
}

function snapIndexToAxis(idx, last){
  if (!snapWalls || !snapWalls.checked || !last) return idx;
  const dx = Math.abs(idx.ix - last.x);
  const dy = Math.abs(idx.iy - last.y);
  if (dx >= dy) return {ix: idx.ix, iy: last.y};
  return {ix: last.x, iy: idx.iy};
}

function wallColor(loss){
  if (loss >= 18) return 'rgba(255, 136, 136, 0.9)';
  if (loss >= 12) return 'rgba(255, 196, 132, 0.9)';
  if (loss >= 8) return 'rgba(255, 236, 180, 0.9)';
  return 'rgba(190, 220, 255, 0.9)';
}

function drawWallPolyline(ctx2, points, loss){
  if (!points || points.length < 2) return;
  const glow = 'rgba(0, 0, 0, 0.35)';
  ctx2.save();
  ctx2.lineJoin = 'round';
  ctx2.lineCap = 'round';
  ctx2.setLineDash([Math.max(6, scale * 0.25), Math.max(4, scale * 0.18)]);
  ctx2.strokeStyle = glow;
  ctx2.lineWidth = Math.max(4, scale * 0.24);
  ctx2.beginPath();
  ctx2.moveTo(toPixelX(points[0].x), toPixelY(points[0].y));
  for (let i=1;i<points.length;i++){
    ctx2.lineTo(toPixelX(points[i].x), toPixelY(points[i].y));
  }
  ctx2.stroke();
  ctx2.setLineDash([]);
  ctx2.strokeStyle = wallColor(loss);
  ctx2.lineWidth = Math.max(2, scale * 0.14);
  ctx2.beginPath();
  ctx2.moveTo(toPixelX(points[0].x), toPixelY(points[0].y));
  for (let i=1;i<points.length;i++){
    ctx2.lineTo(toPixelX(points[i].x), toPixelY(points[i].y));
  }
  ctx2.stroke();
  ctx2.restore();
}

function draw(){
  if (!simCanvas) return;
  ctx.clearRect(0,0,simCanvas.width,simCanvas.height);
  // background
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0, 0, simCanvas.width, simCanvas.height);
  const areaX = pad - 6;
  const areaY = pad - 6;
  const areaW = cols * scale + 12;
  const areaH = rows * scale + 12;
  const panelGrad = ctx.createLinearGradient(areaX, areaY, areaX + areaW, areaY + areaH);
  panelGrad.addColorStop(0, 'rgba(18, 26, 40, 0.9)');
  panelGrad.addColorStop(1, 'rgba(12, 18, 30, 0.9)');
  ctx.fillStyle = panelGrad;
  roundedRectPath(ctx, areaX, areaY, areaW, areaH, 14);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
  ctx.lineWidth = 1;
  ctx.stroke();
  // subtle frosted hatch
  ctx.save();
  ctx.globalAlpha = 0.07;
  ctx.strokeStyle = '#dfe8ff';
  for (let x = areaX - areaH; x < areaX + areaW; x += 18){
    ctx.beginPath();
    ctx.moveTo(x, areaY + areaH);
    ctx.lineTo(x + areaH, areaY);
    ctx.stroke();
  }
  ctx.restore();
  drawBackgroundImage(ctx, areaX, areaY, areaW, areaH);

  // compute heatmap colors (cells should already have rssi)
  for (const c of cells){
    const px = pad + c.xIndex*scale + 2;
    const py = pad + c.yIndex*scale + 2;
    const w = scale - 4;
    const h = scale - 4;
    const radius = Math.max(2, Math.min(8, scale * 0.18));
    const fill = (c.rssi === null) ? 'rgba(255, 255, 255, 0.12)' : rssiToColor(c.rssi);
    const isStrong = c.rssi !== null && c.rssi > -65;
    if (isStrong){
      ctx.save();
      ctx.shadowColor = rgbToRgba(fill, 0.45);
      ctx.shadowBlur = Math.max(8, scale * 0.45);
      roundedRectPath(ctx, px - 1, py - 1, w + 2, h + 2, radius + 2);
      ctx.strokeStyle = rgbToRgba(fill, 0.5);
      ctx.lineWidth = Math.max(1.4, scale * 0.1);
      ctx.stroke();
      ctx.restore();
    }
    roundedRectPath(ctx, px, py, w, h, radius);
    ctx.strokeStyle = (c.rssi === null) ? 'rgba(255, 255, 255, 0.15)' : rgbToRgba(fill, 0.6);
    ctx.lineWidth = Math.max(1.4, scale * 0.08);
    ctx.stroke();
  }

  if (showGrid){
    const gridStep = gridStepForScale(scale);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
    ctx.lineWidth = 1;
    for (let i=0;i<=cols;i+=gridStep){
      const x = pad + i*scale;
      ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad + rows*scale); ctx.stroke();
    }
    for (let j=0;j<=rows;j+=gridStep){
      const y = pad + j*scale;
      ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad + cols*scale, y); ctx.stroke();
    }
  }

  // draw walls (polylines)
  for (const w of walls){
    drawWallPolyline(ctx, w.points, w.loss);
  }

  // draw APs
  aps.forEach((a, idx)=>{
    const px = toPixelX(a.xIndex), py = toPixelY(a.yIndex);
    ctx.beginPath(); ctx.fillStyle = '#0d6efd'; ctx.arc(px, py, Math.max(6, scale*0.2), 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.font = `${Math.max(10, scale*0.18)}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('AP'+(idx+1), px, py);
    if (idx === selectedAPIndex){
      ctx.beginPath(); ctx.strokeStyle = '#5de0e6'; ctx.lineWidth = 3;
      ctx.arc(px, py, Math.max(10, scale*0.3), 0, Math.PI*2); ctx.stroke();
    }
  });

  // draw RSSI numbers
  ctx.fillStyle = '#fff';
  ctx.font = `${Math.max(9, scale*0.18)}px "Sora", sans-serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  for (const c of cells){
    if (c.rssi === null) continue;
    const px = toPixelX(c.xIndex), py = toPixelY(c.yIndex);
    const color = rssiToColor(c.rssi);
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 4;
    ctx.fillStyle = color;
    ctx.fillText(Math.round(c.rssi), px, py);
    ctx.restore();
  }

  // footer info
  ctx.fillStyle = 'rgba(238, 243, 251, 0.75)';
  ctx.font = '12px "Sora", sans-serif';
  ctx.fillText(`Room ${W}m×${H}m • Cell ${cellSize}m • Grid ${cols}×${rows}`, 14, simCanvas.height - 10);
}

// color mapping (smooth)
function rssiToColor(rssi){
  if (rssi === null) return '#f1f3f5';
  if (rssi <= -75) return 'rgb(255, 90, 90)';
  const v = Math.max(RSSI_MIN, Math.min(RSSI_MAX, rssi));
  const norm = (v - RSSI_MIN) / (RSSI_MAX - RSSI_MIN);
  // modern gradient: indigo -> aqua -> lime
  let r,g,b;
  if (norm < 0.5){
    const t = norm / 0.5;
    r = Math.round(64 + (80 - 64) * t);
    g = Math.round(72 + (210 - 72) * t);
    b = Math.round(255 - (255 - 220) * t);
  } else {
    const t = (norm - 0.5) / 0.5;
    r = Math.round(80 + (96 - 80) * t);
    g = Math.round(210 + (245 - 210) * t);
    b = Math.round(220 - (220 - 150) * t);
  }
  return `rgb(${r},${g},${b})`;
}

function rgbToRgba(rgb, alpha){
  const m = rgb.match(/(\d+),\s*(\d+),\s*(\d+)/);
  if (!m) return `rgba(124, 247, 161, ${alpha})`;
  return `rgba(${m[1]}, ${m[2]}, ${m[3]}, ${alpha})`;
}
function getTextColorForBg(rgb){ // choose black or white based on luminance
  const m = rgb.match(/(\d+),\s*(\d+),\s*(\d+)/);
  if (!m) return '#000';
  const r = +m[1], g = +m[2], b = +m[3];
  const lum = 0.2126*r + 0.7152*g + 0.0722*b;
  return lum > 150 ? '#000' : '#fff';
}

// compute RSSI for each cell: for each AP compute rssi and pick max
function computeRSSI(){
  for (const c of cells) { c.rssi = null; c.bestAP = null; }
  for (let i=0;i<aps.length;i++){
    const a = aps[i];
    for (const c of cells){
      const res = rssiFromAPToCell(a, c);
      if (c.rssi === null || res.rssi > c.rssi){
        c.rssi = res.rssi; c.bestAP = i;
      }
    }
  }
  updateStats();
}

// rssi for AP->cell, including wall intersection sums
function rssiFromAPToCell(ap, cell){
  // positions in meters
  const apX = (ap.xIndex + 0.5) * cellSize;
  const apY = (ap.yIndex + 0.5) * cellSize;
  const cx = cell.cx, cy = cell.cy;
  let dist = Math.hypot(cx - apX, cy - apY);
  if (dist < 0.5) dist = 0.5;
  // sum wall losses by checking intersection of AP-cell segment with each wall polyline segment
  let totalWallLoss = 0;
  for (const poly of walls){
    for (let k=1;k<poly.points.length;k++){
      const p1 = poly.points[k-1], p2 = poly.points[k];
      // segment in meters
      const wx1 = (p1.x + 0.5) * cellSize, wy1 = (p1.y + 0.5) * cellSize;
      const wx2 = (p2.x + 0.5) * cellSize, wy2 = (p2.y + 0.5) * cellSize;
      if (segmentIntersect(apX,apY,cx,cy, wx1,wy1,wx2,wy2)){
        totalWallLoss += poly.loss;
      }
    }
  }
  const Ptx = ap.ptx;
  const freq = parseFloat(freqSel.value);
  const d_km = dist/1000;
  const fspl = 20*Math.log10(d_km) + 20*Math.log10(freq) + 32.44;
  const rssi = Ptx - fspl - totalWallLoss;
  return {rssi, dist, totalWallLoss, fspl};
}

// segment intersection (robust float)
function segmentIntersect(x1,y1,x2,y2,x3,y3,x4,y4){
  // based on orientation
  function orient(ax,ay,bx,by,cx,cy){ return (bx-ax)*(cy-ay) - (by-ay)*(cx-ax); }
  const o1 = orient(x1,y1,x2,y2,x3,y3);
  const o2 = orient(x1,y1,x2,y2,x4,y4);
  const o3 = orient(x3,y3,x4,y4,x1,y1);
  const o4 = orient(x3,y3,x4,y4,x2,y2);
  if ((o1*o2 < 0) && (o3*o4 < 0)) return true;
  return false;
}

// UI interactions: mouse events for freehand drawing and placing APs/moving them
simCanvas.addEventListener('mousedown', (e)=>{
  isMouseDown = true;
  const rect = simCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const idx = pixelToIndex(mx,my);
  if (!idx) return;
  const apHit = findAPAtIndex(idx.ix, idx.iy);
  if (apHit !== null){
    setSelectedAP(apHit);
    if (mode === 'moveAP'){
      moveAPIndex = apHit;
    } else if (mode === 'eraseAP'){
      aps.splice(apHit, 1);
      if (selectedAPIndex === apHit) setSelectedAP(null);
      computeRSSI(); draw();
    }
    return;
  }
  if (mode === 'addAP'){
    aps.push({xIndex: idx.ix, yIndex: idx.iy, ptx: parseFloat(PtxInput.value)});
    setSelectedAP(aps.length - 1);
    computeRSSI(); draw();
  } else if (mode === 'moveAP'){
    // find AP at clicked cell
    const found = aps.findIndex(a=>a.xIndex===idx.ix && a.yIndex===idx.iy);
    if (found >=0) moveAPIndex = found;
  } else if (mode === 'eraseAP'){
    const found = aps.findIndex(a=>a.xIndex===idx.ix && a.yIndex===idx.iy);
    if (found >=0){
      aps.splice(found,1); computeRSSI(); draw();
      if (selectedAPIndex === found) setSelectedAP(null);
    }
  } else if (mode === 'drawWall'){
    // start polyline
    currentPoly = { points: [{x: idx.ix, y: idx.iy}], loss: parseFloat(wallTypeSel.value) };
  } else if (mode === 'eraseWall'){
    // remove any wall polyline if clicked point is near any segment
    const px = (idx.ix + 0.5)*cellSize, py = (idx.iy + 0.5)*cellSize;
    let removed = false;
    for (let i=walls.length-1;i>=0;i--){
      const poly = walls[i];
      for (let s=1;s<poly.points.length;s++){
        const a = poly.points[s-1], b = poly.points[s];
        const wx1 = (a.x+0.5)*cellSize, wy1 = (a.y+0.5)*cellSize;
        const wx2 = (b.x+0.5)*cellSize, wy2 = (b.y+0.5)*cellSize;
        const d = distancePointToSegment(px,py, wx1,wy1,wx2,wy2);
        if (d < cellSize*0.6){ walls.splice(i,1); removed=true; break; }
      }
      if (removed) break;
    }
    if (removed){ computeRSSI(); draw(); }
  }
});

simCanvas.addEventListener('mousemove', (e)=>{
  const rect = simCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const idx = pixelToIndex(mx,my);
  updateHoverInspector(idx);
  if (!isMouseDown) return;
  if (!idx) return;
  if (mode === 'moveAP' && moveAPIndex !== null){
    aps[moveAPIndex].xIndex = idx.ix; aps[moveAPIndex].yIndex = idx.iy;
    computeRSSI(); draw();
  } else if (mode === 'drawWall' && currentPoly){
    // add point if moved into new cell
    const last = currentPoly.points[currentPoly.points.length-1];
    const snapped = snapIndexToAxis(idx, last);
    if (last.x !== snapped.ix || last.y !== snapped.iy){
      currentPoly.points.push({x: snapped.ix, y: snapped.iy});
      // draw temporary
      draw();
      // draw polyline preview
      drawWallPolyline(ctx, currentPoly.points, currentPoly.loss);
    }
  }
});

simCanvas.addEventListener('mouseup', (e)=>{
  isMouseDown = false;
  if (mode === 'drawWall' && currentPoly){
    if (currentPoly.points.length > 1) walls.push(currentPoly);
    currentPoly = null;
    computeRSSI(); draw();
  }
  moveAPIndex = null;
});

simCanvas.addEventListener('mouseleave', ()=>{
  updateHoverInspector(null);
});

function findAPAtIndex(ix, iy){
  const found = aps.findIndex(a=>a.xIndex===ix && a.yIndex===iy);
  return found >= 0 ? found : null;
}

function setSelectedAP(index){
  if (index === null || index === undefined){
    selectedAPIndex = null;
  } else {
    selectedAPIndex = index;
  }
  updateSelectedAPInspector();
  draw();
}

// helpers for erase/geometry
function distancePointToSegment(px,py, x1,y1,x2,y2){
  const l2 = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
  if (l2 === 0) return Math.hypot(px-x1, py-y1);
  let t = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
  t = Math.max(0, Math.min(1, t));
  const projx = x1 + t*(x2-x1), projy = y1 + t*(y2-y1);
  return Math.hypot(px-projx, py-projy);
}

// export PNG: draw offscreen at higher resolution then save
function exportPNG(){
  const scaleExport = 2;
  const oc = document.createElement('canvas'); oc.width = simCanvas.width*scaleExport; oc.height = simCanvas.height*scaleExport;
  const octx = oc.getContext('2d');
  octx.scale(scaleExport, scaleExport);
  // draw background similar to draw()
  octx.fillStyle = '#0b1220';
  octx.fillRect(0, 0, oc.width, oc.height);
  const areaX = pad - 6;
  const areaY = pad - 6;
  const areaW = cols * scale + 12;
  const areaH = rows * scale + 12;
  const panelGrad = octx.createLinearGradient(areaX, areaY, areaX + areaW, areaY + areaH);
  panelGrad.addColorStop(0, 'rgba(18, 26, 40, 0.9)');
  panelGrad.addColorStop(1, 'rgba(12, 18, 30, 0.9)');
  octx.fillStyle = panelGrad;
  roundedRectPath(octx, areaX, areaY, areaW, areaH, 14);
  octx.fill();
  octx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
  octx.lineWidth = 1;
  octx.stroke();
  octx.save();
  octx.globalAlpha = 0.07;
  octx.strokeStyle = '#dfe8ff';
  for (let x = areaX - areaH; x < areaX + areaW; x += 18){
    octx.beginPath();
    octx.moveTo(x, areaY + areaH);
    octx.lineTo(x + areaH, areaY);
    octx.stroke();
  }
  octx.restore();
  drawBackgroundImage(octx, areaX, areaY, areaW, areaH);
  // cells
  for (const c of cells){
    const px = pad + c.xIndex*scale + 2;
    const py = pad + c.yIndex*scale + 2;
    const w = scale - 4;
    const h = scale - 4;
    const radius = Math.max(2, Math.min(8, scale * 0.18));
    const fill = (c.rssi === null) ? 'rgba(255, 255, 255, 0.12)' : rssiToColor(c.rssi);
    const isStrong = c.rssi !== null && c.rssi > -65;
    if (isStrong){
      octx.save();
      octx.shadowColor = rgbToRgba(fill, 0.45);
      octx.shadowBlur = Math.max(8, scale * 0.45);
      roundedRectPath(octx, px - 1, py - 1, w + 2, h + 2, radius + 2);
      octx.strokeStyle = rgbToRgba(fill, 0.5);
      octx.lineWidth = Math.max(1.4, scale * 0.1);
      octx.stroke();
      octx.restore();
    }
    roundedRectPath(octx, px, py, w, h, radius);
    octx.strokeStyle = (c.rssi === null) ? 'rgba(255, 255, 255, 0.15)' : rgbToRgba(fill, 0.6);
    octx.lineWidth = Math.max(1.4, scale * 0.08);
    octx.stroke();
  }
  // walls
  for (const w of walls){
    drawWallPolyline(octx, w.points, w.loss);
  }
  // APs
  aps.forEach((a, i)=>{
    const px = toPixelX(a.xIndex), py = toPixelY(a.yIndex);
    octx.beginPath(); octx.fillStyle = '#0d6efd'; octx.arc(px,py, Math.max(6, scale*0.2),0,Math.PI*2); octx.fill();
    octx.strokeStyle = '#fff'; octx.lineWidth = 2; octx.stroke();
    octx.fillStyle = '#fff'; octx.font = `${Math.max(10, scale*0.18)}px sans-serif`; octx.textAlign='center'; octx.textBaseline='middle'; octx.fillText('AP'+(i+1), px, py);
  });
  // RSSI numbers
  octx.font = `${Math.max(9, scale*0.18)}px "Sora", sans-serif`;
  octx.textAlign='center'; octx.textBaseline='middle';
  for (const c of cells){
    if (c.rssi === null) continue;
    const px = toPixelX(c.xIndex), py = toPixelY(c.yIndex);
    const color = rssiToColor(c.rssi);
    octx.save();
    octx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    octx.shadowBlur = 4;
    octx.fillStyle = color;
    octx.fillText(Math.round(c.rssi), px, py);
    octx.restore();
  }
  const url = oc.toDataURL('image/png');
  const a = document.createElement('a'); a.href = url; a.download = 'wifi-heatmap.png'; a.click();
}

// auto-place APs: greedy candidates + local refinement
function autoPlaceAPs(k){
  if (cells.length === 0) { alert('Generate grid first'); return; }
  // candidate set: sample cells (we'll use all cells but can be limited)
  const candidates = cells.slice();
  const originalAps = aps.slice();
  // Greedy selection: pick AP that maximizes #cells > -65 not already covered
  const placed = [];
  const coveredRSSI = Array(cells.length).fill(-Infinity);
  for (let n=0;n<k;n++){
    let bestIdx = -1, bestGain = -Infinity, bestRssiArr = null;
    for (let ci=0;ci<candidates.length;ci++){
      const cand = candidates[ci];
      const testAP = {xIndex:cand.xIndex, yIndex:cand.yIndex, ptx: parseFloat(PtxInput.value)};
      // compute new best rssi if this AP added
      let gain = 0;
      const newRssiArr = [];
      for (let i=0;i<cells.length;i++){
        const cell = cells[i];
        const cur = coveredRSSI[i];
        const res = rssiFromAPToCell(testAP, cell);
        const nv = Math.max(cur, res.rssi);
        newRssiArr.push(nv);
        if (nv > -65 && cur <= -65) gain += 1;
        gain += (nv - cur)*0.0001;
      }
      if (gain > bestGain){ bestGain = gain; bestIdx = ci; bestRssiArr = newRssiArr; }
    }
    if (bestIdx === -1) break;
    // commit best
    const chosen = candidates[bestIdx];
    aps.push({xIndex: chosen.xIndex, yIndex: chosen.yIndex, ptx: parseFloat(PtxInput.value)});
    // update coveredRSSI
    for (let i=0;i<cells.length;i++) coveredRSSI[i] = bestRssiArr[i];
  }
  // local refinement: try moving each placed AP within radius to improve global strong-count
  let improved = true, iter=0;
  while (improved && iter < 6){
    improved = false; iter++;
    for (let ai=0; ai<aps.length; ai++){
      let bestLocal = {score: scoreCoverage(), x: aps[ai].xIndex, y: aps[ai].yIndex};
      // try neighbors within 2 cells
      for (let dx=-2; dx<=2; dx++){
        for (let dy=-2; dy<=2; dy++){
          const nx = aps[ai].xIndex + dx, ny = aps[ai].yIndex + dy;
          if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
          const save = {x: aps[ai].xIndex, y: aps[ai].yIndex};
          aps[ai].xIndex = nx; aps[ai].yIndex = ny;
          computeRSSI();
          const sc = scoreCoverage();
          if (sc > bestLocal.score + 0.0001){ bestLocal = {score: sc, x: nx, y: ny}; }
          // revert
          aps[ai].xIndex = save.x; aps[ai].yIndex = save.y;
        }
      }
      if (bestLocal.x !== aps[ai].xIndex || bestLocal.y !== aps[ai].yIndex){
        aps[ai].xIndex = bestLocal.x; aps[ai].yIndex = bestLocal.y; improved = true; computeRSSI();
      }
    }
  }
  computeRSSI(); draw();
}

function scoreCoverage(){
  // score = weighted sum of strong cells + small bonus for medium
  let score = 0;
  for (const c of cells){
    if (c.rssi === null) continue;
    if (c.rssi > -65) score += 1;
    else if (c.rssi > -75) score += 0.4;
    else score += 0;
  }
  return score;
}

// utility: computeRSSI & draw wrapper
function computeAndRender(){ computeRSSI(); draw(); }

// update stats
function updateStats(){
  let strong=0, medium=0, weak=0;
  for (const c of cells){
    if (c.rssi === null) continue;
    if (c.rssi > -65) strong++;
    else if (c.rssi > -75) medium++;
    else weak++;
  }
  statTotal.textContent = cells.length;
  statStrong.textContent = strong;
  statMedium.textContent = medium;
  statWeak.textContent = weak;
  statWalls.textContent = walls.length;
  statAps.textContent = aps.length;
  updateLiveMeta();
  updateSelectedAPInspector();

  const userCountInput = document.getElementById('numUsers');
  const totalUsers = parseInt(userCountInput.value) || 20;
  showRecommendedDevices(cells, totalUsers);
}

function updateHoverInspector(idx){
  if (!insCell || !insRSSI || !insBestAp || !insDist || !insLoss) return;
  if (!idx || cols === 0 || rows === 0){
    insCell.textContent = '—';
    insRSSI.textContent = '—';
    insBestAp.textContent = '—';
    insDist.textContent = '—';
    insLoss.textContent = '—';
    return;
  }
  const cell = cells[idx.iy * cols + idx.ix];
  if (!cell){
    insCell.textContent = '—';
    insRSSI.textContent = '—';
    insBestAp.textContent = '—';
    insDist.textContent = '—';
    insLoss.textContent = '—';
    return;
  }
  insCell.textContent = `${idx.ix + 1}, ${idx.iy + 1}`;
  if (cell.rssi === null || cell.bestAP === null){
    insRSSI.textContent = '—';
    insBestAp.textContent = '—';
    insDist.textContent = '—';
    insLoss.textContent = '—';
    return;
  }
  const ap = aps[cell.bestAP];
  if (!ap){
    insRSSI.textContent = `${Math.round(cell.rssi)} dBm`;
    insBestAp.textContent = '—';
    insDist.textContent = '—';
    insLoss.textContent = '—';
    return;
  }
  const res = rssiFromAPToCell(ap, cell);
  insRSSI.textContent = `${Math.round(res.rssi)} dBm`;
  insBestAp.textContent = `AP ${cell.bestAP + 1}`;
  insDist.textContent = `${res.dist.toFixed(2)} m`;
  insLoss.textContent = `${res.totalWallLoss.toFixed(1)} dB`;
}

function updateSelectedAPInspector(){
  if (!insSelAp || !insSelPos || !insSelTx || !insSelScore || !insSelCovered || !insSelAvg) return;
  if (selectedAPIndex === null || !aps[selectedAPIndex]){
    insSelAp.textContent = '—';
    insSelPos.textContent = '—';
    insSelTx.textContent = '—';
    insSelScore.textContent = '—';
    insSelCovered.textContent = '—';
    insSelAvg.textContent = '—';
    drawSparkline([]);
    return;
  }
  const ap = aps[selectedAPIndex];
  const posX = ((ap.xIndex + 0.5) * cellSize).toFixed(2);
  const posY = ((ap.yIndex + 0.5) * cellSize).toFixed(2);
  insSelAp.textContent = `AP ${selectedAPIndex + 1}`;
  insSelPos.textContent = `${ap.xIndex + 1}, ${ap.yIndex + 1} (${posX}m, ${posY}m)`;
  insSelTx.textContent = `${ap.ptx} dBm`;
  let strong = 0;
  let covered = 0;
  let avg = 0;
  let avgCount = 0;
  const samples = [];
  for (const c of cells){
    if (c.bestAP === selectedAPIndex){
      covered++;
      if (c.rssi > -65) strong++;
      if (c.rssi !== null){ avg += c.rssi; avgCount++; }
      if (c.rssi !== null) samples.push(c.rssi);
    }
  }
  insSelScore.textContent = `${strong}`;
  insSelCovered.textContent = `${covered}`;
  insSelAvg.textContent = avgCount ? `${(avg / avgCount).toFixed(1)} dBm` : '—';
  drawSparkline(samples);
}

function drawSparkline(values){
  if (!insSpark) return;
  const ctx2 = insSpark.getContext('2d');
  if (!ctx2) return;
  const w = insSpark.width;
  const h = insSpark.height;
  ctx2.clearRect(0, 0, w, h);
  ctx2.fillStyle = 'rgba(10, 16, 28, 0.45)';
  ctx2.fillRect(0, 0, w, h);
  if (!values || values.length === 0){
    ctx2.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx2.beginPath();
    ctx2.moveTo(8, h / 2);
    ctx2.lineTo(w - 8, h / 2);
    ctx2.stroke();
    return;
  }
  const minV = Math.min(...values, RSSI_MIN);
  const maxV = Math.max(...values, RSSI_MAX);
  const range = Math.max(1, maxV - minV);
  const step = values.length > 1 ? (w - 16) / (values.length - 1) : 0;
  ctx2.strokeStyle = 'rgba(93, 224, 230, 0.9)';
  ctx2.lineWidth = 2;
  ctx2.beginPath();
  values.forEach((v, i)=>{
    const x = 8 + i * step;
    const y = h - 8 - ((v - minV) / range) * (h - 16);
    if (i === 0) ctx2.moveTo(x, y);
    else ctx2.lineTo(x, y);
  });
  ctx2.stroke();
  ctx2.strokeStyle = 'rgba(255, 255, 255, 0.18)';
  ctx2.strokeRect(0.5, 0.5, w - 1, h - 1);
}

function showRecommendedDevices(cells, totalUsers){
  // Find weakest RSSI
  const minRSSI = Math.min(...cells.map(c=>c.rssi||-100));

  // Devices database
  const devices = [
  // UniFi
  {brand:"Unifi", model:"U6 Pro", tx:20, maxUsers:100},
  {brand:"Unifi", model:"U6 LR", tx:20, maxUsers:100},
  {brand:"Unifi", model:"U6 Lite", tx:20, maxUsers:50},
  {brand:"Unifi", model:"U7 Pro", tx:23, maxUsers:300},
  {brand:"Unifi", model:"U7 Pro Max", tx:23, maxUsers:500},
  {brand:"Unifi", model:"U7 Pro Wall", tx:22, maxUsers:250},
  {brand:"Unifi", model:"UAP-AC-PRO", tx:20, maxUsers:100},
  {brand:"Unifi", model:"UAP-AC-LITE", tx:20, maxUsers:50},
  {brand:"Unifi", model:"UAP-AC-MESH", tx:20, maxUsers:50},
  {brand:"Unifi", model:"UAP-AC-OUTDOOR", tx:20, maxUsers:50},

  // MikroTik
  {brand:"MikroTik", model:"cAP ac", tx:20, maxUsers:100},
  {brand:"MikroTik", model:"cAP XL ac", tx:20, maxUsers:200},
  {brand:"MikroTik", model:"cAP ax", tx:22, maxUsers:200},
  {brand:"MikroTik", model:"cAP ax XL", tx:22, maxUsers:250},
  {brand:"MikroTik", model:"wAP ac", tx:20, maxUsers:50},
  {brand:"MikroTik", model:"wAP LTE6", tx:20, maxUsers:50},
  {brand:"MikroTik", model:"hAP ac²", tx:20, maxUsers:100},
  {brand:"MikroTik", model:"hAP ax²", tx:20, maxUsers:100},
  {brand:"MikroTik", model:"hAP ax³", tx:22, maxUsers:200},

  // EnGenius
  {brand:"EnGenius", model:"ECW230", tx:23, maxUsers:200},
  {brand:"EnGenius", model:"ECW220", tx:20, maxUsers:100},
  {brand:"EnGenius", model:"ECW120", tx:20, maxUsers:50},
  {brand:"EnGenius", model:"ECW110", tx:20, maxUsers:50},
  {brand:"EnGenius", model:"ECW530", tx:23, maxUsers:300},
  {brand:"EnGenius", model:"ECW220S", tx:20, maxUsers:100},
  {brand:"EnGenius", model:"ECW230S", tx:23, maxUsers:200},
  {brand:"EnGenius", model:"ECW336", tx:23, maxUsers:400},

  // Ruijie
  {brand:"Ruijie", model:"RG-AP9861-R", tx:23, maxUsers:500},
  {brand:"Ruijie", model:"RG-AP9220", tx:23, maxUsers:500},
  {brand:"Ruijie", model:"RG-AP880-E", tx:20, maxUsers:300},
  {brand:"Ruijie", model:"RG-AP880-AR", tx:20, maxUsers:300},
  {brand:"Ruijie", model:"RG-AP850-AR(V3)", tx:20, maxUsers:200},
  {brand:"Ruijie", model:"RG-AP840-I(V2)", tx:20, maxUsers:200},
  {brand:"Ruijie", model:"RG-AP820-AR(V3)", tx:20, maxUsers:150},
  {brand:"Ruijie", model:"RG-AP820-I", tx:20, maxUsers:150},
  {brand:"Ruijie", model:"RG-AP810-I", tx:20, maxUsers:100},
  {brand:"Ruijie", model:"RG-AP1800-I", tx:22, maxUsers:200},

  // Tenda
  {brand:"Tenda", model:"AC10", tx:20, maxUsers:50},
  {brand:"Tenda", model:"AC6", tx:20, maxUsers:50},
  {brand:"Tenda", model:"TX3", tx:22, maxUsers:100},
  {brand:"Tenda", model:"MW6", tx:20, maxUsers:50},
  {brand:"Tenda", model:"MW3", tx:20, maxUsers:50},
  {brand:"Tenda", model:"MW12", tx:20, maxUsers:100},
  {brand:"Tenda", model:"MW5", tx:20, maxUsers:50},

  // Totolink
  {brand:"Totolink", model:"CA3000X-PoE", tx:20, maxUsers:100},
  {brand:"Totolink", model:"CA1200-PoE", tx:20, maxUsers:50},
  {brand:"Totolink", model:"CA300-PoE", tx:20, maxUsers:50},
  {brand:"Totolink", model:"CP900L", tx:20, maxUsers:50},
  {brand:"Totolink", model:"CP300L", tx:20, maxUsers:50},
  {brand:"Totolink", model:"CP450", tx:20, maxUsers:50},

  // TP-Link
  {brand:"TP-Link", model:"EAP650", tx:22, maxUsers:250},
  {brand:"TP-Link", model:"EAP610", tx:20, maxUsers:200},
  {brand:"TP-Link", model:"EAP670", tx:23, maxUsers:300},
  {brand:"TP-Link", model:"EAP225", tx:20, maxUsers:150},

  // Cisco
  {brand:"Cisco", model:"Catalyst 9115AX", tx:23, maxUsers:300},
  {brand:"Cisco", model:"Catalyst 9120AX", tx:23, maxUsers:400},
  {brand:"Cisco", model:"Catalyst 9130AX", tx:23, maxUsers:500},

  // Aruba
  {brand:"Aruba", model:"AP-515", tx:22, maxUsers:300},
  {brand:"Aruba", model:"AP-535", tx:23, maxUsers:500},
  {brand:"Aruba", model:"AP-505", tx:20, maxUsers:200},

  // Ruckus
  {brand:"Ruckus", model:"R550", tx:22, maxUsers:350},
  {brand:"Ruckus", model:"R650", tx:23, maxUsers:500},
  {brand:"Ruckus", model:"R750", tx:23, maxUsers:750},

  // Speedify
  {brand:"Speedify", model:"R1", tx:18, maxUsers:15},
];


  // Approximate recommendation with ±10 dBm and ±10 users tolerance
const recommended = devices.filter(d => {
    const txOk = d.tx >= parseFloat(PtxInput.value) - 10 && d.tx <= parseFloat(PtxInput.value) + 10; // ±10 dBm
    const usersOk = totalUsers >= d.maxUsers - 10 && totalUsers <= d.maxUsers + 10;               // ±10 users
    return txOk && usersOk;
});


  const list = recommended.map(d=>`${d.brand} ${d.model} (TX ${d.tx} dBm, Max Users: ${d.maxUsers})`).join("<br>") || "No suitable devices found";

  let recDiv = document.getElementById('recommendedDevices');
  if(!recDiv){
    recDiv = document.createElement('div');
    recDiv.id = 'recommendedDevices';
    recDiv.className = 'alert alert-info mt-3';
    const container = document.querySelector('.results') || document.body;
    container.appendChild(recDiv);
  }
  recDiv.innerHTML = `<strong>Recommended Devices:</strong><br>${list}`;
}




// --------------------- Animated AI Placement ---------------------
async function aiPlaceAPsAnimated(k, iterations=500){
    if (cells.length===0){ alert('Generate grid first'); return; }

    // initialize random AP positions
    let current = [];
    for (let i=0;i<k;i++){
        const x = Math.floor(Math.random()*cols);
        const y = Math.floor(Math.random()*rows);
        current.push({xIndex:x, yIndex:y, ptx: parseFloat(PtxInput.value)});
    }

    let best = current.map(a=>({...a}));
    let bestScore = scorePlacement(best);

    let T = 5.0; // initial temperature
    const alpha = 0.995; // cooling rate

    for (let iter=0;iter<iterations;iter++){
        // pick one AP and move it randomly
        let next = current.map(a=>({...a}));
        const ai = Math.floor(Math.random()*k);
        const dx = Math.floor(Math.random()*5)-2; // -2..2
        const dy = Math.floor(Math.random()*5)-2;
        next[ai].xIndex = Math.max(0, Math.min(cols-1, next[ai].xIndex+dx));
        next[ai].yIndex = Math.max(0, Math.min(rows-1, next[ai].yIndex+dy));

        const nextScore = scorePlacement(next);
        const delta = nextScore - scorePlacement(current);

        if (delta>0 || Math.random() < Math.exp(delta/T)){
            current = next.map(a=>({...a})); // accept move
        }

        if (nextScore>bestScore){
            best = next.map(a=>({...a}));
            bestScore = nextScore;
        }

        T *= alpha;

        // Animate every few iterations
        if (iter % 5 === 0){
            aps = current.map(a=>({...a}));
            computeAndRender();
            await new Promise(r => setTimeout(r, 10)); // small delay for animation
        }
    }

    // Final placement
    aps = best.map(a=>({...a}));
    computeAndRender();
}

// Add animated AI placement button
// const aiAnimBtn = document.createElement('button');
// aiAnimBtn.className = 'btn btn-outline-danger mt-2 w-100';
// aiAnimBtn.textContent = 'AI Placement (Animated)';
// aiAnimBtn.addEventListener('click', ()=>{
//     const k = Math.max(1, parseInt(autoCount.value)||1);
//     aiPlaceAPsAnimated(k, 700); // 700 iterations
// });
// document.querySelector('.controls').appendChild(aiAnimBtn);

// score placement: count strong + medium coverage cells
function scorePlacement(apArr){
  const tempCells = cells.map(c=>({...c, rssi:null}));
  for (let i=0;i<apArr.length;i++){
    const a = apArr[i];
    for (const c of tempCells){
      const res = rssiFromAPToCell(a, c);
      if (c.rssi===null || res.rssi>c.rssi) c.rssi=res.rssi;
    }
  }
  let score=0;
  for (const c of tempCells){
    if (c.rssi===null) continue;
    if (c.rssi > -65) score += 1;
    else if (c.rssi > -75) score += 0.4;
  }
  return score;
}

// add a new button for AI placement
// const aiBtn = document.createElement('button');
// aiBtn.className = 'btn btn-outline-warning mt-2 w-100';
// aiBtn.textContent = 'AI-Powered Placement';
// aiBtn.addEventListener('click', ()=> {
//   const k = Math.max(1, parseInt(autoCount.value)||1);
//   aiPlaceAPs(k, 700); // 700 iterations by default
// });
// document.querySelector('.controls').appendChild(aiBtn);
// --------------------- End of AI Simulated Annealing ---------------------

// wire UI
PtxInput.addEventListener('input', ()=>{ PtxVal.textContent = PtxInput.value + ' dBm'; // update ptx of existing APs as global
  for (const a of aps) a.ptx = parseFloat(PtxInput.value); computeAndRender();});
freqSel.addEventListener('change', computeAndRender);
generateBtn.addEventListener('click', ()=>{ generateGrid(); computeAndRender(); });
clearWallsBtn.addEventListener('click', ()=>{ walls = []; computeAndRender(); });
clearAllBtn.addEventListener('click', ()=>{ walls=[]; aps=[]; computeAndRender(); });
fitBtn.addEventListener('click', ()=>{ fitToView(); });

autoPlaceBtn.addEventListener('click', ()=>{ const k = Math.max(1, parseInt(autoCount.value)||1); autoPlaceAPs(k); });

// initial grid
generateGrid();
computeAndRender();
if (hudGrid) hudGrid.classList.toggle('active', showGrid);
// If weakest coverage is -65 dBm and you want at least -75 dBm at cell
// let minRSSI = Math.min(...cells.map(c => c.rssi || -100));
// const requiredTx = Math.abs(minRSSI); // e.g., 10 dB margin



// export PNG
exportBtn.addEventListener('click', exportPNG);

// small utility to make legend gradient visible (set background)
legendBar.style.background = 'linear-gradient(90deg,#dc3545,#ffc107,#28a745)';

// helper to convert hex/rgb -> text color (already included above)
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// End of script
</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
